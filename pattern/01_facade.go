package main

import "strings"

/*
	Реализовать паттерн «фасад».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Facade_pattern
*/

/*
Фасад - паттерн, структурирующий объекты.
Он позволяет избежать привязки отправителя запроса к его получателю,
давая шанс обработать запрос нескольким объектам.
Связывает объекты-получатели в цепочку и передает запрос вдоль этой цепочки,
пока его не обработают.

Применимость паттерна:
- когда необходимо предоставить простой интерфейс к сложной подсистеме;
- когда между клиентами и классами реализации абстракции существует много зависимостей;
- вы необходимо разложить подсистему на отдельные слои.

Плюсы и минусы:
- изолирует клиентов от компонентов подсистемы, уменьшая тем самым число объектов,
с которыми клиентам приходится иметь дело, и упрощая работу с подсистемой;
- позволяет ослабить связанность между подсистемой и ее клиентами;
- фасад не препятствует приложениям напрямую обращаться к классам подсистемы, если это необходимо.

Примеры использования:
- системы компиляции языка ObjectWorks\Smalltalk
*/

// NewBaker создает пекаря
func NewBaker() *Baker {
	return &Baker{
		pie:      &Pie{},
		doughnut: &Doughnut{},
	}
}

// Baker реализует пекаря
type Baker struct {
	pie      *Pie
	doughnut *Doughnut
}

// Cook реализует приготовление выпечки
func (m *Baker) Cook() string {
	result := []string{
		m.pie.Bake(),
		m.doughnut.Make(),
	}
	return strings.Join(result, "\n")
}

// Bread реализует структуру пирога
type Pie struct {
}

// Bake реализация приготовления пирога
func (h *Pie) Bake() string {
	return "Bake pie"
}

// Doughnut реализует структуру пончика
type Doughnut struct {
}

// Make реализация приготовления пончика
func (t *Doughnut) Make() string {
	return "Doughnut make"
}

func main() {
	baker := NewBaker()
	baker.Cook()
}
